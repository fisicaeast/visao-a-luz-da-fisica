<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
    <title>Página de Física EAST</title>
    
    <link type="text/css" rel="stylesheet" href="../../css/aulas.css" />   
    <link type="text/css" rel="stylesheet" href="css_e_js/local.css" />

    <link href='../../comunHtml/syntaxhighlighter/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='../../comunHtml/syntaxhighlighter/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='../../comunHtml/syntaxhighlighter/scripts/shCore.js' type='text/javascript'></script>
    <script src='./comunHtml/syntaxhighlighter/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='../../comunHtml/syntaxhighlighter/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='../../comunHtml/syntaxhighlighter/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='../../comunHtml/syntaxhighlighter/scripts/shBrushCss.js' type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushPython.js" type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushPhp.js" type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushFortran.js" type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushCpp.js"  type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushAsm.js"  type='text/javascript'></script>
    <script type="text/javascript">
      SyntaxHighlighter.config.clipboardSwf = '../../comunHtml/syntaxhighlighter/scripts/clipboard.swf';https://tex.stackexchange.com/questions/58141/equations-inside-enumerate-aligned-on-items-number
      SyntaxHighlighter.all();
    </script>

     <script>
       window.MathJax = {
         tex: {
           tags: 'ams',
           inlineMath: [['$', '$'], ['\\(', '\\)']],
           macros: {
              bra: ["{\\left\\langle #1 \\right\\rvert}",1],
              ket: ["{\\left\\lvert #1 \\right\\rangle}",1],
              braket:["{\\left\\langle #1 \\vert #2 \\right\\rangle}",2],
              opProj:["{\\left\\lvert #1 \\right\\rangle\\left\\langle #1 \\right\\rvert}",1],
              opUni:["{\\left\\lvert #1 \\right\\rangle\\left\\langle #1 \\right\\rvert \+ \\left\\lvert #2 \\right\\rangle\\left\\langle #2 \\right\\rvert}",2],
              arcsec: "{\\operatorname{arcsec}}",
              arccot: "{\\operatorname{arccot}}",
              arccsc: "{\\operatorname{arcsc}}",
              sech: "{\\operatorname{sech}}",
              csch: "{\\operatorname{csch}}",
              argsinh: "{\\operatorname{arg sinh}}",
              argcosh: "{\\operatorname{arg cosh}}",
              argtanh: "{\\operatorname{arg tanh}}",
              argcoth: "{\\operatorname{arg coth}}",
              argsech: "{\\operatorname{arg sech}}",
              argcsch: "{\\operatorname{arg csch}}",
              dbar: "{\\mathscr'26\\mkern-12mu \\mathrm{d}}"
          }
         }
       };
     </script>    

    <script src="../../comunHtml/mathjax_new/tex-chtml.js" id="MathJax-script" async></script>
    
    <script type="text/javascript">
      function newWin(url, name, width) { 
      window.open(url,name,'scrollbars=yes,resizable=yes, width=' + width);}
    </script>
    
    <script src="../../comunHtml/jquery/dist/jquery.min.js"></script>
    <script>
    $(document).ready(function(){
      $(".expand").click(function(){
        target_num = $(this).attr("id").split("-")[1];
        content_id = "#expandable-".concat(target_num);
        $(content_id).slideToggle('fast');
      });
    });
    </script>

    <style>
      .expand {
        font-style: italic;
        font-size: 12px;
        cursor: pointer;
        color: blue;
      }
        .expandable {
        display:none;
        margin-left: 3%;
        margin-right: 3%;
        color: #3e3e3e;
/*         text-align: justify; */
      }
    </style>
    
    <style>
      ol.alpha_list {
        counter-reset: item;
        list-style: none;
      }
      ol.alpha_list li:before {
        content: counter(item,  lower-latin) ")  ";
        counter-increment: item;
        margin-left: -30px;
      }
    </style>

</head>

  <body>
    <div id="todo">

      <div id="titulo">      
        <div id="cabezado">
          <h1>Visão à luz da Física</h1>
        </div>

        <div >
          <img src="../../figuras/divisorHorizontal.png" alt="só um divisor"></img>
        </div>


      <!-- Inicio Principal   -->
      <div id="principal">
      
      <h2>Transmissão de informação utilizando luz</h2>
      
      <p>
        Com o auxílio do dispositivo que descreveremos a seguir, será possível discutir com os alunos como a informação pode ser transmitida utilizando luz. Para isso, será proposta uma forma simples de codificação da informação, que permitirá apresentar as ideias básicas relacionadas aos protocolos de comunicação.
      </p>
      
      <p>
        O dispositivo experimental utilizado foi constituído por duas partes: um emissor de luz laser pulsada, onde se codifica e transmite a informação, e um receptor de luz, que decodifica a informação e executa uma ação. No caso do receptor forma utilizado duas versões, uma com o sensor LDR e outra com o sensor BPW34
      </p>
        
      <div  align="center">
        <a href="javascript:newWin('figuras/fig01.png', 'Zoom', '1650')">
          <img src="figuras/fig01.png" style="width:80%">
        </a>
        <p style="text-align: center; font-size:70%">
          Figura 01: À esquerda emissão de pulsos laser, à direita o receptor.
        </p>
      </div>
      
      <h3>Aplicação</h3>
      
      <p>
        Para utilizar o dispositivo, siga os seguintes passos:
        <ol>
          <li>
            Ligar o Receptor
            <ol>
              <li>
                Conecte o Receptor à fonte de alimentação. Se o Arduino já estiver energizado, isso equivale a apertar o botão de reset.
              </li>
              <li>
                O Receptor realizará leituras do sensor da luz do ambiente durante 10 segundos para calcular um valor médio de referência que será usado para distinguir o feixe do laser da luz do ambiente.
              </li>
            </ol>
          </li>
          <li>
            Calibração Inicial do Receptor
            <ol>
              <li>
                Após a medição da luz ambiente, o display do Receptor exibirá a mensagem "Aperte o botão amarelo para calibrar".
              </li>
              <li>
                Quando o laser estiver pronto para emitir, aperte o botão amarelo no Receptor para que ele entre em modo de calibração, onde:
                <ol>
                  <li>O Receptor monitora as transições do sinal do laser.</li>
                  <li>
                    As medidas são realizadas até que o sensor não registre variações por mais de 500 ms.
                  </li>
                  <li>
                    Após esse período de inatividade, o Receptor calcula a frequência e o duty cycle (D+ e D-) do sinal (tempo que fica ligado e tempo que fica desligado) e exibe os resultados no display e no Serial; por fim, pisca o LED branco cálido imitando a frequência medida.
                  </li>
                  <li>
                    Se a frequência medida for muito alta (por exemplo, T = 0), o receptor imprimirá no OLED que a frequência deve ser reajustada para um valor menor e que o botão amarelo seja pressionado novamente.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            Ligar o Emissor
            <ol>
              <li>
                Conecte o Emissor à fonte de alimentação.
              </li>
              <li>
                Logo após ligar, o Emissor entra no estado de ajuste de período, para isso deve seguir-se os seguintes passos:
                <ol>
                  <li>
                    Gire o potenciômetro para alterar o período do laser, sendo possível obter pulsos com &Delta;T de 1 a 132 ms.
                  </li>
                  <li>
                    O display mostra o período de oscilação (o dobro do tempo de cada pulso do laser).
                  </li>
                  <li>
                    Concluído o ajuste, aperte o botão amarelo no Emissor para confirmar o período. Em seguida, o Emissor exibirá "Ligue o receptor" e aguardará 5 segundos antes de ligar o laser.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            Calibração do Emissor
            <ol>
              <li>
                Após a pausa de 5 segundos, o Emissor emitirá os pulsos do laser, piscando o LED branco quente em sincronia com o laser por 20 segundos.
              </li>
              <li>
                Se necessário, repita a calibração pressionando novamente o botão amarelo para acessar a função de calibração.
              </li>
            </ol>
          </li>
          <li>
            Sincronização da Calibração no Receptor
            <ol>
              <li>
                Caso o Receptor ainda não tenha lido a frequência ou se você desejar recalibrá-lo, aperte o botão amarelo no Receptor enquanto o Emissor estiver emitindo seus pulsos de calibração.
              </li>
              <li>
                O Receptor monitorará as transições do laser até detectar 500 ms sem variações. Seguidamente, serão realizados os cálculos e exibidos os resultados (período T, duty cycle D+ e D-) no display.
              </li>
            </ol>
          </li>
          <li>
            Emissão de Pulsos Coloridos
            <ol>
              <li>
                Após as calibrações, o Emissor passa para o estado de espera, imprimindo no display a mensagem "Calibração concluída. Aperte algum botão".
              </li>
              <li>
                O usuário pode voltar ao estado de ajuste da frequência do laser ou escolher apertar algum dos botões coloridos, cada botão desses emitirá uma quantidade específica de pulsos:
                <ol>
                  <li>Vermelho: emite T1 pulsos.</li>
                  <li>Verde: emite T2 pulsos.</li>
                  <li>Azul: emite T3 pulsos.</li>
                </ol>
              </li>
              <li>
                Cálculo dos Pulsos: O número desses pulsos é calculado conforme:
                <ol>
                  <li>\( T0 = \dfrac{2000}{\Delta T} \)</li>
                  <li>\( T1 = 0,95 \times T0 \)</li>
                  <li>\( T2 = 0,95 \times \left(2 \times T0\right) \)</li>
                  <li>\( T3 = 0,95 \times \left(3 \times T0\right) \)</li>
                </ol>
                sendo &Delta;T a metade do período do laser. O fator de 0,95 leva em consideração o fato de que o &Delta;T calculado no emissor não é exatamente igual ao &Delta;T detectado no receptor, existindo ligeiras divergências de 1 a 2 ms, se o sensor LDR for utilizado.
              </li>
            </ol>
          </li>
          <li>
            Detecção e Classificação no Receptor.
            <ol>
              <li>
                O Receptor conta o número de pulsos recebidos até que haja um período de inatividade. Dependendo do número desses pulsos, um LED vermelho, verde ou azul será ligado por 1 s.
              </li>
              <li>
                Internamente o receptor determina o valor de \( T0 \) usando a mesma equação anterior
                \[
                  T0 = \dfrac{2000}{\Delta T}
                \]
                e, a partir desse valor, estabelece os limites de intervalo de pulsos que correspondem a cada cor, conforme:
                <ul>
                  <li>Vermelho: entre 0 e T1 pulsos;</li>
                  <li>Verde: entre T1 e 2 T1 pulsos;</li>
                  <li>Azul: entre 2 T1 e 3 T1 pulsos.</li>
                </ul>
                Ao final, uma mensagem no display informará a cor detectada e a quantidade de pulsos.
              </li>
              <li>
                Se o número de pulsos for maior do que 3 T1 pulsos, o Receptor exibirá uma mensagem de "pulsos inválidos".
              </li>
            </ol>
          </li>
        </ol>
      </p>
      
      <h3>Materiais</h3>

      <p>
        Para o emissor:
        <ul>
          <li>1 Arduino Nano</li>
          <li>1 Fonte ajustável para protoboard</li>
          <li>1 matriz de contato ou protoboard MB102</li>
          <li>4 resistores de 10 k&Omega; e 1 resistor de 330 &Omega;</li>
          <li>1 Potenciômetro, $P_1 = 10 k&Omega;</li>
          <li>4 botões (push button), com capas nas cores vermelho, verde, azul e amarelo</li>
          <li>1 telinha OLED de 0,96 polegadas</li>
          <li>Cabos de conexão, 23 - 24 AWG (diâmetro entre 0,574 e 0,511 mm)</li>
          <li>1 LED branco quente</li>
        </ul>
      </p>

      <p>
        Para o receptor utilizamos os itens comuns:
        <ul>
          <li>1 Arduino Nano</li>
          <li>1 Fonte ajustável para protoboard</li>
          <li>1 matriz de contato ou protoboard MB102</li>
          <li>4 resistores de 330 &Omega;, e 1 resistor de 10 k&Omega;</li>
          <li>1 botão (push button), com capa na cor amarela</li>
          <li>1 telinha OLED de 0,96 polegadas</li>
          <li>Cabos de conexão, 23 - 24 AWG (diâmetro entre 0,574 e 0,511 mm)</li>
          <li>4 LEDs nas cores vermelho, verde, azul e branco quente</li>
        </ul>
      </p>

      <p>
        Itens adicionais (dependendo do sensor utilizado):
        <ul>
          <li>No caso do LDR, é utilizado 1 resistor de 1 k&Omega;</li>
          <li>Se é o BPW34, é utilizado um resistor de 410 &Omega;</li>
        </ul>
      </p>
      
      <h3>Montagem</h3>
      
      <h4>Emissor</h4>
      
      <div style="flex: 30%; padding-right: 30px">
        <a href="javascript:newWin('figuras/fig02.png', 'Zoom', '1650')">
          <img src="figuras/fig02.png" style="width:100%">
        </a>
        <p style="text-align: center; font-size:80%">
          Figura 02: Emissor, à direita a foto real, à esquerda esquema do feito com fritzing, embaixo o esquema de ligação
        </p>
      </div>

      <p>
        <ul>
          <li>
            Coloque o Arduino NANO no centro, próximo a um dos extremos da protoboard MB102.
          </li>
          <li>
            No outro extremo do MB102 coloque a fonte de energia respeitando a polaridade: positivo no trilho vermelho e negativo na trilha azul.
          </li>
          <li>
            Conecte o terminal central do potenciômetro de 10 k&Omega; ao pino A0 do Arduino. Os outros terminais devem ser ligados aos trilhos azul e vermelho para fornecer energia.
          </li>
          <li>
            Ligue o terminal negativo do laser ao trilho azul do protoboard e o pino S do laser ao pino D7 do Arduino.
          </li>
          <li>
            Ligue o ânodo (terminal mais comprido) do LED branco quente ao pino 6 do Arduino, através de um resistor de 330 &Omega;. O cátodo desse LED deve ser ligado ao trilho preto do protoboard.
          </li>
          <li>
            O terminal GND da telinha OLED deve ser ligado à trilha vermelha do protoboard e o terminal VCC à trilha azul. Os terminais SDA e SCL devem ser ligados aos pinos A4 e A5 do Arduino, respectivamente.
          </li>
          <li>
            Os quatro botões devem ser distribuídos no espaço disponível entre o display OLED e a fonte de tensão do protoboard. A configuração adotada para a ligação com o Arduino é a chamada "Pull-down": Um dos lados do botão é conectado à fonte de energia (trilho vermelho), e o outro terminal é conectado ao trilho azul através de um resistor de R = 10 k&Omega;. Um dos outros dois terminais (aquele oposto ao terminal em série com a resistência) é ligado diretamente aos pinos D5, D4, D3, D2; relativos aos botões que estão próximos ao OLED, em direção à fonte de tensão do protoboard.
          </li>
        </ul>
      </p>
      
      <div style="flex: 30%; padding-right: 30px">
        <a href="javascript:newWin('figuras/fig03.png', 'Zoom', '1650')">
          <img src="figuras/fig03.png" style="width:100%">
        </a>
        <p style="text-align: center; font-size:80%">
          Figura 03: Esquema de ligação do emissor
        </p>
      </div>
      
      <h5>Programação</h5>
      
      <p>
        Este programa é uma versão melhorada do utilizado originalmente. A essência do programa original não foi modificada somante alterando a organização e estruturação do mesmo, alterando o nome das variáveis a fim de tornar elas mais em acordo com seu uso dentro do programa
      </p>
      
      <pre class="brush: cpp;">
        #include &lt;Wire.h&gt;
        #include &lt;U8g2lib.h&gt;

        // ================== DEFINIÇÕES E VARIÁVEIS GLOBAIS ==================

        // Display
        #define MY_FONT u8g2_font_9x18_tr
        U8G2_SSD1306_128X64_NONAME_1_HW_I2C display(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); // Voltamos ao construtor C++

        // Pinos
        int pinBotaoR = 2;
        int pinBotaoG = 3;
        int pinBotaoB = 4;
        int pinBotaoY = 5;
        int pinLed    = 6;
        int pinLaser  = 7;

        // Leitura do potenciômetro
        int valor_pot;
        int tempoDelay = 10;

        // Quantidade de pulsos (float)
        float T1, T2, T3;

        // Porcentagem de pulsos
        #define PORC_PULSOS 0.95f

        // Estados dos botões (voltamos a usar bool)
        bool sitBotaoR = false; // false = LOW = não pressionado
        bool sitBotaoG = false;
        bool sitBotaoB = false;
        bool sitBotaoY = false;

        // Variáveis de calibração
        unsigned long t1 = 0, t2 = 0, t1Local;
        bool estado = false;

        // Cor selecionada (1=R, 2=G, 3=B)
        int corSelecionada = 0;

        // ================== MÁQUINA DE ESTADOS ==================

        enum EstadoEmissor {
          EST_INICIAL,
          EST_AJUSTA_PERIODO,
          EST_CALIBRA_LASER,
          EST_AGUARDA_ACAO,
          EST_EMITE_PULSO
        };

        EstadoEmissor estadoAtual = EST_INICIAL;

        // ================== PROTÓTIPOS DE FUNÇÕES ==================

        void maquinaDeEstadosEmissor();
        void estadoAjustaPeriodo();
        void estadoCalibraLaser();
        void estadoAguardaAcao();
        void estadoEmitePulso();
        void blink(int n);
        void calibra();
        void mudaFrequencia();
        void mensagem(int cor);
        void logMensagem(const String& linha1, const String& linha2 = "", const String& linha3 = "", const String& linha4 = ""); // Usando String


        // ================== SETUP ==================

        void setup() {
            Serial.begin(57600);

            pinMode(pinLed, OUTPUT);
            pinMode(pinLaser, OUTPUT);
            pinMode(pinBotaoR, INPUT); // Pull-down externo, então INPUT
            pinMode(pinBotaoG, INPUT);
            pinMode(pinBotaoB, INPUT);
            pinMode(pinBotaoY, INPUT);

            // Inicializa display (C++)
            Wire.begin();
            display.begin();        // Muito mais simples!
            display.setPowerSave(0); // Desliga power save

            estadoAtual = EST_AJUSTA_PERIODO;
            logMensagem("Emissor Iniciado");
        }

        // ================== LOOP PRINCIPAL ==================

        void loop() {
            // Leitura dos botões (HIGH = pressionado, LOW = não pressionado)
            sitBotaoR = digitalRead(pinBotaoR);
            sitBotaoG = digitalRead(pinBotaoG);
            sitBotaoB = digitalRead(pinBotaoB);
            sitBotaoY = digitalRead(pinBotaoY);

            // Executa a máquina de estados
            maquinaDeEstadosEmissor();
        }

        // ------------------ MÁQUINA DE ESTADOS ------------------
        void maquinaDeEstadosEmissor() {
          switch (estadoAtual) {
            case EST_INICIAL:
              break;

            case EST_AJUSTA_PERIODO:
              estadoAjustaPeriodo();
              break;

            case EST_CALIBRA_LASER:
              estadoCalibraLaser();
              break;

            case EST_AGUARDA_ACAO:
              estadoAguardaAcao();
              break;

            case EST_EMITE_PULSO:
              estadoEmitePulso();
              break;
          }
        }

        // ------------------ ESTADO: AJUSTA PERIODO ------------------
        void estadoAjustaPeriodo() {
          mudaFrequencia();
          estadoAtual = EST_CALIBRA_LASER;
        }

        // ------------------ ESTADO: CALIBRA LASER ------------------
        void estadoCalibraLaser() {
          calibra();
          estadoAtual = EST_AGUARDA_ACAO;
        }

        // ------------------ ESTADO: AGUARDA AÇÃO (BOTÕES) ------------------
        void estadoAguardaAcao() {
            // Se o botão Y for pressionado, voltamos para ajustar período.
          if (sitBotaoY == HIGH) { // Agora HIGH significa pressionado.
            estadoAtual = EST_AJUSTA_PERIODO;
            logMensagem("Botao amarelo", "Voltando Ajuste");
            return;
          }
          // Se algum dos botões R, G ou B for pressionado, vamos emitir pulso.
          if (sitBotaoR == HIGH) { // Agora HIGH significa pressionado.
            corSelecionada = 1; // Vermelho
            estadoAtual = EST_EMITE_PULSO;
            logMensagem("Botao vermelho");
          }
          else if (sitBotaoG == HIGH) { // Agora HIGH significa pressionado.
            corSelecionada = 2; // Verde
            estadoAtual = EST_EMITE_PULSO;
            logMensagem("Botao verde");
          }
          else if (sitBotaoB == HIGH) { // Agora HIGH significa pressionado.
            corSelecionada = 3; // Azul
            estadoAtual = EST_EMITE_PULSO;
            logMensagem("Botao azul");
          }
        }

        // ------------------ ESTADO: EMITE PULSO ------------------
        void estadoEmitePulso() {
          // Emite a quantidade de pulsos *ajustada* conforme a cor.
          if (corSelecionada == 1) {
            blink(static_cast&lt;int&gt;(T1)); // Converte float para int
            mensagem(1);
          } else if (corSelecionada == 2) {
            blink(static_cast&lt;int&gt;(T2)); // Cast para int
            mensagem(2);
          } else if (corSelecionada == 3) {
            blink(static_cast&lt;int&gt;(T3)); // Cast para int
            mensagem(3);
          }
          estadoAtual = EST_AGUARDA_ACAO;
        }

        // ================== FUNÇÕES DE APOIO ==================

        void blink(int n){
          for (int i=0; i < n; i++){
            digitalWrite(pinLed,   HIGH);
            digitalWrite(pinLaser, HIGH);
            delay(tempoDelay);
            digitalWrite(pinLaser, LOW);
            digitalWrite(pinLed,   LOW);
            delay(tempoDelay);
          }
        }

        void calibra(){
          t1Local = millis();
          do {
            t2 = millis();
            if (t2 - t1 >= tempoDelay){
              t1 = t2;
              digitalWrite(pinLaser, estado);
              digitalWrite(pinLed,   estado);
              estado   = !estado;
            }
          } while (millis() - t1Local < 20000);

          digitalWrite(pinLaser, LOW);
          digitalWrite(pinLed,   LOW);
          logMensagem("Calibracao", "concluida ...", "Aperte algum", "botao");
        }

        // Funções com Modificações (mudaFrequencia, mensagem, logMensagem):

        void mudaFrequencia() {
            logMensagem("Aj. o Periodo", "Amarelo para sair");

            do {
                valor_pot = analogRead(A0);
                tempoDelay = map(valor_pot, 0, 1023, 1, 132); // Simplificado com map() do Arduino

                logMensagem("Aj. o periodo", "Periodo: " + String(2 * tempoDelay) + " ms", "Amarelo para", "sair"); // Usando String

                sitBotaoY = digitalRead(pinBotaoY);
            } while (sitBotaoY == LOW);

            logMensagem("Ligue", "o receptor");
            delay(5000);

            // Calcula T1, T2 e T3 (sem porcentagem primeiro)
            float T1_original = (2000.0f / tempoDelay);
            float T2_original = 2.0f * T1_original;
            float T3_original = 3.0f * T1_original;

            // Aplica a porcentagem
            T1 = T1_original * PORC_PULSOS;
            T2 = T2_original * PORC_PULSOS;
            T3 = T3_original * PORC_PULSOS;

            logMensagem("Periodo Ajustado",
                        "T1: " + String(int(T1)),  // Conversão implícita e explícita para int
                        "T2: " + String(int(T2)),
                        "T3: " + String(int(T3)));

            t1 = millis(); // Para a calibração.
        }

        void mensagem(int cor) {
            String linha1;
            String linha2;

            if (cor == 1) {
                linha1 = "Vermelho:";
                linha2 = String(int(T1)) + " pulsos"; // String + int
            } else if (cor == 2) {
                linha1 = "Verde:";
                linha2 = String(int(T2)) + " pulsos";
            } else if (cor == 3) {
                linha1 = "Azul:";
                linha2 = String(int(T3)) + " pulsos";
            }

            logMensagem(linha1, linha2);
        }

        void logMensagem(const String& linha1, const String& linha2, const String& linha3, const String& linha4) {
            display.firstPage();
            do {
                display.setFont(MY_FONT);
                display.drawStr(0, 15, linha1.c_str());  // Correção aqui: drawStr, e .c_str()
                if (linha2.length() > 0) display.drawStr(0, 30, linha2.c_str()); // Correção aqui
                if (linha3.length() > 0) display.drawStr(0, 45, linha3.c_str()); // Correção aqui
                if (linha4.length() > 0) display.drawStr(0, 60, linha4.c_str()); // Correção aqui
            } while (display.nextPage());

            // Saída para o Serial Monitor (agora usando print/println)
            Serial.println(linha1);
            if (linha2.length() > 0) Serial.println(linha2);
            if (linha3.length() > 0) Serial.println(linha3);
            if (linha4.length() > 0) Serial.println(linha4);
        }
      </pre>
      
      <h6>Análise do Programa</h6>
          <p>
            Este programa implementa um emissor de pulsos de laser controlado por um Arduino Nano. Ele organiza seu fluxo por meio de uma máquina de estados, permitindo que o usuário ajuste o período de pulsação via potenciômetro, realize uma calibração do laser e emita pulsos em quantidades diferentes conforme o botão de cor pressionado.
          </p>
          <ol>
            <li>
              <p>Bibliotecas e definições iniciais</p>
              <ul>
                <li>
                  São utilizadas as bibliotecas Wire e U8g2lib para a comunicação I2C com o display OLED.
                </li>
                <li>
                  São definidas variáveis globais para os pinos (botões, LED, laser), para a leitura do potenciômetro e para armazenar os valores de calibração e de pulsos (T1, T2, T3).
                </li>
              </ul>
            </li>
            <li>
              <p>Configuração (Setup)</p>
              <ul>
                <li>
                  Inicializa a comunicação serial a 57600 bps.
                </li>
                <li>
                  Configura os pinos do Arduino como saída (para o LED e o laser) ou entrada (para os botões), assumindo uma ligação com resistor pull-down externo.
                </li>
                <li>
                  Inicia o display OLED e desliga o modo de economia de energia.
                </li>
                <li>
                  Define o estado inicial da máquina de estados como ajuste de período e exibe a mensagem "Emissor Iniciado" tanto no display quanto no Serial.
                </li>
              </ul>
            </li>
            <li>
              <p>Loop Principal</p>
              <ul>
                <li>
                  A cada iteração, o programa lê os estados dos botões (vermelho, verde, azul e amarelo).
                </li>
                <li>
                  Em seguida, chama a função da máquina de estados, que gerencia a execução dos diferentes modos de operação.
                </li>
              </ul>
            </li>
            <li>
              <p>Máquina de Estados</p>
              <ul>
                <li>
                  O programa define cinco estados: EST_INICIAL, EST_AJUSTA_PERIODO, EST_CALIBRA_LASER, EST_AGUARDA_ACAO e EST_EMITE_PULSO.
                </li>
                <li>
                  Cada estado tem uma função associada. Por exemplo, no estado EST_AJUSTA_PERIODO, a função mudaFrequencia() é chamada para ajustar o período do laser com base no valor lido pelo potenciômetro.
                </li>
                <li>
                  Após o ajuste, o estado passa para EST_CALIBRA_LASER, onde a função calibra() é executada, fazendo o LED e o laser piscarem por 20 segundos.
                </li>
                <li>
                  Depois da calibração, o sistema entra no estado EST_AGUARDA_ACAO, onde aguarda o usuário apertar um dos botões: o botão amarelo retorna ao ajuste, enquanto os botões de cor (vermelho, verde ou azul) levam à emissão de pulsos.
                </li>
                <li>
                  No estado EST_EMITE_PULSO, a função blink() é chamada para emitir a quantidade de pulsos correspondente à cor selecionada, e o sistema retorna ao estado de espera.
                </li>
              </ul>
            </li>
            <li>
              <p>Ajuste do Período (mudaFrequencia)</p>
              <ul>
                <li>
                  O potenciômetro é lido (via analogRead em A0) e o valor é mapeado para um intervalo entre 1 e 132 ms, atribuindo esse valor à variável tempoDelay.
                </li>
                <li>
                  O display mostra o período de oscilação, que é o dobro do tempoDelay (pois cada pulso tem um período ligado e outro desligado).
                </li>
                <li>
                  O usuário confirma o ajuste pressionando o botão amarelo; o programa então pausa por 5 segundos e calcula os valores T1, T2 e T3.
                </li>
                <li>
                  T1 é calculado como 0,95 × (2000 / tempoDelay), T2 como 0,95 × 2 × (2000 / tempoDelay) e T3 como 0,95 × 3 × (2000 / tempoDelay). Esses valores representam a quantidade de pulsos a serem emitidos para cada cor.
                </li>
              </ul>
            </li>
            <li>
              <p>Calibração do Laser (calibra)</p>
              <ul>
                <li>
                  Durante 20 segundos, a função calibra() alterna o estado do LED e do laser a cada tempoDelay ms, fazendo com que pisquem repetidamente.
                </li>
                <li>
                  Após 20 segundos, ambos são desligados e é exibida uma mensagem informando que a calibração foi concluída.
                </li>
              </ul>
            </li>
            <li>
              <p>Espera por Ação (estadoAguardaAcao)</p>
              <ul>
                <li>
                  Se o botão amarelo for pressionado, o sistema retorna ao estado de ajuste de período.
                </li>
                <li>
                  Se um dos botões de cor (vermelho, verde ou azul) for pressionado, o sistema define a cor selecionada e passa ao estado de emissão de pulsos.
                </li>
              </ul>
            </li>
            <li>
              <p>Emissão de Pulsos (estadoEmitePulso e blink)</p>
              <ul>
                <li>
                  A função blink(n) é chamada com n igual a T1, T2 ou T3 (convertido para inteiro), emitindo n pulsos. Cada pulso consiste em tempoDelay ms ligado e tempoDelay ms desligado.
                </li>
                <li>
                  Após emitir os pulsos, o programa chama a função mensagem() para exibir, no display e no Serial, a cor selecionada e o número de pulsos emitidos.
                </li>
                <li>
                  O sistema retorna ao estado de espera por ação.
                </li>
              </ul>
            </li>
            <li>
              <p>Exibição de Mensagens (mensagem e logMensagem)</p>
              <ul>
                <li>
                  A função mensagem() monta as strings que contêm o nome da cor (Vermelho, Verde ou Azul) e o número de pulsos (T1, T2 ou T3) a serem emitidos.
                </li>
                <li>
                  A função logMensagem() exibe essas mensagens no display OLED e as envia ao Serial Monitor, permitindo monitorar o status do sistema.
                </li>
              </ul>
            </li>
          </ol>
          <p>
          
      <h4>Receptor LDR</h4>
      
      <div style="flex: 30%; padding-right: 30px">
        <a href="javascript:newWin('figuras/fig04.png', 'Zoom', '1650')">
          <img src="figuras/fig04.png" style="width:100%">
        </a>
        <p style="text-align: center; font-size:80%">
          Figura 04: Recepto com LDR, à direita a foto real, à esquerda esquema do feito com fritzing, embaixo o esquema de ligação
        </p>
      </div>


      <p>
        <ul>
          <li>Coloque o Arduino NANO no centro, próximo a um dos extremos da protoboard MB102.</li>
          <li>No outro extremo do MB102 coloque a fonte de energia respeitando a polaridade: positivo no trilho vermelho e negativo na trilha azul.</li>
          <li>O sensor de luz é um dos elementos que constitui um divisor de tensão, em que a resistência Rs parte desde o terminal negativo do protoboard, e continua em série com o sensor de luz que coloca seu outro terminal no polo positivo do protoboard. No caso do LDR a resistência utilizada é de 1 k&Omega;, e no caso do BPW34 é 410&Omega;.</li>
          <li>O terminal GND da telinha OLED deve ser ligado à trilha vermelha do protoboard e o terminal VCC à trilha azul. Os terminais SDA e SCL devem ser ligados aos pinos A4 e A5 do Arduino, respectivamente.</li>
          <li>Os quatro LEDs devem ser distribuídos no espaço disponível entre o display OLED e a fonte de tensão do protoboard. O cátodo desses LEDs deve ser ligado a uma resistência de 330&Omega; ao qual se liga ao trilho azul do protoboard. Já o ânodo (perna mais comprida do LED) é ligado diretamente aos pinos D6, D5, D4, D3; para os LEDs branco quente, vermelho, verde e azul, respectivamente.</li>
        </ul>
      </p>
      
      <div style="flex: 30%; padding-right: 30px">
        <a href="javascript:newWin('figuras/fig05.png', 'Zoom', '1650')">
          <img src="figuras/fig05.png" style="width:100%">
        </a>
        <p style="text-align: center; font-size:80%">
          Figura 05: Recepto com LDR, à direita a foto real, à esquerda esquema do feito com fritzing, embaixo o esquema de ligação
        </p>
      </div>
      
      
      <h5>Programação</h5>
      
      <p>
        Este programa é uma versão melhorada do utilizado originalmente. A essência do programa original não foi modificada somante alterando a organização e estruturação do mesmo, alterando o nome das variáveis a fim de tornar elas mais em acordo com seu uso dentro do programa
      </p>
      
      <pre class="brush: cpp;">
        #include &lt;Wire.h&gt;
        #include &lt;U8glib.h&gt;

        // --- Definições e Constantes ---
        #define OLED_ADDRESS 0x3C
        #define MY_FONT u8g_font_9x18
        #define TEMPO_LIMITE_INATIVIDADE_CALIBRACAO 500  // 0.5 segundos em ms
        #define ESCALA_LUZ_AMBIENTE 0.708f  // sem ponto-e-vírgula!

        // Pinos
        const int PIN_LED_AZUL     = 2;
        const int PIN_LED_VERDE    = 3;
        const int PIN_LED_VERMELHO = 4;
        const int PIN_LED_OK       = 5;
        const int PIN_BOTAO_Y      = 6;
        const int PIN_SENSOR_LUZ   = A0;

        // --- Variáveis Globais ---
        unsigned long valorLuzAmbiente = 0;
        int contadorPulsos = 0;
        unsigned long ultimoPulso = 0;
        bool sensorAnterior = false;

        unsigned long periodoLaser = 0;
        int limitePulsosVermelho, limitePulsosVerde, limitePulsosAzul;
        unsigned long tempoLimiteInatividade = 0;

        bool calibracaoConcluida = false;  // Indica se a calibração foi concluída
        bool aguardandoNovoPulso = false;  // Para evitar contagens espúrias

        // Variáveis para processamento não bloqueante dos pulsos
        bool processandoPulsos = false;
        unsigned long tempoInicioProcessoPulsos = 0;
        int ledAcionado = -1;

        // Variáveis para o piscar de LED de forma não bloqueante
        bool blinkActive = false;
        unsigned long blinkIntervalNB = 0;
        unsigned long lastBlinkTimeNB = 0;
        int blinkCountTarget = 0;
        int blinkCountNB = 0;
        int blinkPinNB = 0;

        // --- Instância do Display OLED com U8glib ---
        U8GLIB_SSD1306_128X64 u8g(OLED_ADDRESS);

        // --- Máquina de Estados para Calibração ---
        enum EstadoCalibracao {
          INICIO_CALIBRACAO,
          MEDINDO_TRANSICOES,
          CALCULANDO_RESULTADOS,
          AGUARDANDO_COR
        };
        EstadoCalibracao estadoAtualCalibracao = INICIO_CALIBRACAO;

        // Variáveis para a calibração
        unsigned long tLdrOld, t1Local;
        bool estadoLdrOld;
        unsigned long dutyCiclePositivoAcumuladoMs, dutyCicleNegativoAcumuladoMs;
        unsigned long contadorAmostrasPositivas, contadorAmostrasNegativas;
        unsigned long T2;
        unsigned long ultimoPulsoLaser;

        // Variáveis para o estado não bloqueante da fase de cálculo
        // Fases: 0 = iniciar; 1 = aguardar 1500ms; 2 = blink LED; 3 = aguardar 2500ms e finalizar.
        int faseCalculo = 0;
        unsigned long tempoInicioFaseCalculo = 0;
        float avgAltoGlobal = 0.0;
        float avgBaixoGlobal = 0.0;
        float DpGlobal = 0.0;
        float DmGlobal = 0.0;

        // --- Protótipos ---
        void inicializarDisplay();
        void configurarPinos();
        int lerSensorLuz();
        void atualizarContadorPulsos();
        bool verificarTempoLimitePulsos();
        void iniciarProcessamentoPulsos();
        void processarCorPulsosNB();
        void acenderLED(int pinoLED, const char* corTexto, int numPulsos);
        void apagarLEDPulsos();
        void determinarLuzAmbiente();
        void botaoCalibracao();
        void exibirMensagemCor(const char* corTexto, int numPulsos);
        void exibirMensagem(const char* linha1, const char* linha2 = "", const char* linha3 = "", const char* linha4 = "");
        void exibirMensagemSerial(const char* linha1, const char* linha2 = "", const char* linha3 = "", const char* linha4 = "");
        void atualizarBlinkLED();
        void aguardarPressionarBotao();

        void inicializarCalibracaoLaser();
        void estadoMedirTransicoes();
        void estadoCalcularResultados();
        void estadoAguardarCor();
        void calibrarLaser();
        void calcularPeriodoEDutyCycle(unsigned long dutyCiclePositivoAcumuladoMs, 
                                        unsigned long dutyCicleNegativoAcumuladoMs,
                                        unsigned long contadorAmostrasPositivas, 
                                        unsigned long contadorAmostrasNegativas,
                                        unsigned long &T2);
        bool verificarFrequenciaAlta(unsigned long T2);
        void exibirResultadosCalibracao(unsigned long T2, int Dp, int Dm);

        // --- Implementação das Funções ---

        // Inicializa o display usando U8glib
        void inicializarDisplay() {
          Wire.begin();
          delay(100);  // Aguarda estabilização do I2C
          u8g.firstPage();
          do {
            u8g.setFont(MY_FONT);
            u8g.drawStr(0, 10, "Inicializando OLED...");
          } while (u8g.nextPage());
        }

        void configurarPinos() {
          pinMode(PIN_LED_VERMELHO, OUTPUT);
          pinMode(PIN_LED_VERDE, OUTPUT);
          pinMode(PIN_LED_AZUL, OUTPUT);
          pinMode(PIN_LED_OK, OUTPUT);
          pinMode(PIN_BOTAO_Y, INPUT);
          pinMode(PIN_SENSOR_LUZ, INPUT);
        }

        int lerSensorLuz() {
          return analogRead(PIN_SENSOR_LUZ);
        }

        void atualizarContadorPulsos() {
          if (calibracaoConcluida && !aguardandoNovoPulso) {
            int leitura = lerSensorLuz();
            bool sensorAtivo = (leitura < valorLuzAmbiente);
            if (!sensorAnterior && sensorAtivo) {
              contadorPulsos++;
              ultimoPulso = millis();
            }
            sensorAnterior = sensorAtivo;
          }
        }

        bool verificarTempoLimitePulsos() {
          return calibracaoConcluida && ((millis() - ultimoPulso) > tempoLimiteInatividade) && (contadorPulsos > 0);
        }

        // Inicia o processamento dos pulsos: acende o LED correspondente e exibe a mensagem
        void iniciarProcessamentoPulsos() {
          if (!processandoPulsos) {
            if (contadorPulsos <= limitePulsosVermelho) {
              digitalWrite(PIN_LED_VERMELHO, HIGH);
              exibirMensagemCor("vermelho", contadorPulsos);
              ledAcionado = PIN_LED_VERMELHO;
            } else if (contadorPulsos <= limitePulsosVerde) {
              digitalWrite(PIN_LED_VERDE, HIGH);
              exibirMensagemCor("verde", contadorPulsos);
              ledAcionado = PIN_LED_VERDE;
            } else if (contadorPulsos <= limitePulsosAzul) {
              digitalWrite(PIN_LED_AZUL, HIGH);
              exibirMensagemCor("azul", contadorPulsos);
              ledAcionado = PIN_LED_AZUL;
            } else {
              char buffer[32];
              snprintf(buffer, sizeof(buffer), "Pulsos invalidos: %d", contadorPulsos);
              exibirMensagem(buffer);
              aguardandoNovoPulso = true;
              ledAcionado = -1;
            }
            processandoPulsos = true;
            tempoInicioProcessoPulsos = millis();
          }
        }

        // Verifica de forma não bloqueante se o tempo de inatividade foi atingido e, após 1000ms, desliga o LED
        void processarCorPulsosNB() {
          if (!processandoPulsos && verificarTempoLimitePulsos()) {
            iniciarProcessamentoPulsos();
          }
          if (processandoPulsos && (millis() - tempoInicioProcessoPulsos >= 1000)) {
            apagarLEDPulsos();
            processandoPulsos = false;
            contadorPulsos = 0;
          }
        }

        void acenderLED(int pinoLED, const char* corTexto, int numPulsos) {
          digitalWrite(pinoLED, HIGH);
          exibirMensagemCor(corTexto, numPulsos);
        }

        void apagarLEDPulsos() {
          const int leds[] = {PIN_LED_VERMELHO, PIN_LED_VERDE, PIN_LED_AZUL, PIN_LED_OK};
          for (unsigned int i = 0; i < sizeof(leds) / sizeof(leds[0]); i++) {
            digitalWrite(leds[i], LOW);
          }
        }

        // Determina a luz ambiente (realizado em setup – pode ser mantido bloqueante)
        void determinarLuzAmbiente() {
          long somaLuz = 0;
          int contador = 0;
          
          exibirMensagem("Determinando", "o valor da luz", "do ambiente...");
          unsigned long tempoInicial = millis();
          while (millis() - tempoInicial < 10000) {
            somaLuz += lerSensorLuz();
            contador++;
            delay(100);
          }
          
          unsigned long mediaLuz = somaLuz / contador;
          Serial.print(F("Luz ambiente: "));
          Serial.println(mediaLuz);
          valorLuzAmbiente = mediaLuz * ESCALA_LUZ_AMBIENTE;
          Serial.print(F("Luz ambiente escalada = "));
          Serial.println(valorLuzAmbiente);
          
          char buffer1[32], buffer2[32], buffer3[32], buffer4[32];
          snprintf(buffer1, sizeof(buffer1), "Luz ambiente:");
          snprintf(buffer2, sizeof(buffer2), "%lu", mediaLuz);
          snprintf(buffer3, sizeof(buffer3), "reescalada:");
          snprintf(buffer4, sizeof(buffer4), "%lu", valorLuzAmbiente);
          exibirMensagem(buffer1, buffer2, buffer3, buffer4);
          delay(10000);
        }

        void inicializarCalibracaoLaser() {
          dutyCiclePositivoAcumuladoMs = 0;
          dutyCicleNegativoAcumuladoMs = 0;
          contadorAmostrasPositivas = 0;
          contadorAmostrasNegativas = 0;
          T2 = 0;
          tLdrOld = millis();
          t1Local = millis();
          estadoLdrOld = false;
          ultimoPulsoLaser = millis();
          estadoAtualCalibracao = MEDINDO_TRANSICOES;
          exibirMensagem("Medindo", "transicoes", "do laser...");
          calibracaoConcluida = false;
          contadorPulsos = 0;
          aguardandoNovoPulso = false;
          faseCalculo = 0; // Reinicia a fase de cálculo
        }

        void estadoMedirTransicoes() {
          unsigned long tLdr;
          bool estadoLdr;
          long dtLocal;
          
          int leituraLuz = lerSensorLuz();
          estadoLdr = (leituraLuz > valorLuzAmbiente);
          tLdr = millis();
          
          if (estadoLdr != estadoLdrOld) {
            dtLocal = tLdr - tLdrOld;
            if (estadoLdrOld) {
              dutyCiclePositivoAcumuladoMs += dtLocal;
              contadorAmostrasPositivas++;
            } else {
              dutyCicleNegativoAcumuladoMs += dtLocal;
              contadorAmostrasNegativas++;
            }
            tLdrOld = tLdr;
            estadoLdrOld = estadoLdr;
            ultimoPulsoLaser = millis();
          }
          
          if (millis() - ultimoPulsoLaser > TEMPO_LIMITE_INATIVIDADE_CALIBRACAO) {
            estadoAtualCalibracao = CALCULANDO_RESULTADOS;
          }
        }

        void estadoCalcularResultados() {
          if (faseCalculo == 0) {
            // Realiza os cálculos iniciais
            calcularPeriodoEDutyCycle(dutyCiclePositivoAcumuladoMs, dutyCicleNegativoAcumuladoMs,
                                      contadorAmostrasPositivas, contadorAmostrasNegativas, T2);
                                    
            if (verificarFrequenciaAlta(T2)) {
              inicializarCalibracaoLaser();
              return;
            }
          
            if (contadorAmostrasPositivas > 0 && contadorAmostrasNegativas > 0) {
              avgAltoGlobal = (float)dutyCiclePositivoAcumuladoMs / contadorAmostrasPositivas;
              avgBaixoGlobal = (float)dutyCicleNegativoAcumuladoMs / contadorAmostrasNegativas;
              DpGlobal = (int)((avgAltoGlobal / (avgAltoGlobal + avgBaixoGlobal)) * 100.0f);
              DmGlobal = (int)((avgBaixoGlobal / (avgAltoGlobal + avgBaixoGlobal)) * 100.0f);
            }
          
            exibirResultadosCalibracao(T2, (int)DpGlobal, (int)DmGlobal);
            tempoInicioFaseCalculo = millis();
            faseCalculo = 1;
          }
          else if (faseCalculo == 1) {
            if (millis() - tempoInicioFaseCalculo >= 1500) {
              char bufferSerial1[128], bufferSerial2[128], bufferSerial3[128], temp[16];
              snprintf(bufferSerial1, sizeof(bufferSerial1), "T = %lu ms", T2);
              dtostrf(avgAltoGlobal, 5, 2, temp);
              snprintf(bufferSerial2, sizeof(bufferSerial2), "D+: %s ms", temp);
              dtostrf(avgBaixoGlobal, 5, 2, temp);
              snprintf(bufferSerial3, sizeof(bufferSerial3), "D-: %s ms", temp);
              exibirMensagemSerial(bufferSerial1, bufferSerial2, bufferSerial3);
              exibirMensagem(bufferSerial1, bufferSerial2, bufferSerial3);
              delay(2000);
          
              if (periodoLaser > 0) {
                limitePulsosVermelho = 2000 / periodoLaser;
                limitePulsosVerde = 2 * limitePulsosVermelho;
                limitePulsosAzul = 3 * limitePulsosVermelho;
                tempoLimiteInatividade = 10 * periodoLaser;
              }
              // Inicia o piscar do LED OK de forma não bloqueante
              blinkPinNB = PIN_LED_OK;
              blinkIntervalNB = periodoLaser;
              blinkCountTarget = 10;
              blinkCountNB = 0;
              lastBlinkTimeNB = millis();
              blinkActive = true;
          
              faseCalculo = 2;
            }
          }
          else if (faseCalculo == 2) {
            // Atualiza o blink LED
            atualizarBlinkLED();
            if (!blinkActive) {
              tempoInicioFaseCalculo = millis();
              faseCalculo = 3;
            }
          }
          else if (faseCalculo == 3) {
            if (millis() - tempoInicioFaseCalculo >= 2500) {
              estadoAtualCalibracao = AGUARDANDO_COR;
              exibirMensagem("Aguardando cor...");
              calibracaoConcluida = true;
              contadorPulsos = 0;
              faseCalculo = 0;  // Reinicia para a próxima calibração
            }
          }
        }

        void estadoAguardarCor() {
          if (aguardandoNovoPulso && lerSensorLuz() < valorLuzAmbiente) {
            aguardandoNovoPulso = false;
          }
        }

        void calibrarLaser() {
          switch (estadoAtualCalibracao) {
            case INICIO_CALIBRACAO:
              inicializarCalibracaoLaser();
              break;
            case MEDINDO_TRANSICOES:
              estadoMedirTransicoes();
              break;
            case CALCULANDO_RESULTADOS:
              estadoCalcularResultados();
              break;
            case AGUARDANDO_COR:
              estadoAguardarCor();
              break;
          }
        }

        void botaoCalibracao() {
          estadoAtualCalibracao = INICIO_CALIBRACAO;
          calibrarLaser();
        }

        void exibirMensagemCor(const char* corTexto, int numPulsos) {
          char linha1[32], linha2[32], linha3[32], linha4[32];
          snprintf(linha1, sizeof(linha1), "Cor detectada:");
          snprintf(linha2, sizeof(linha2), "%s,", corTexto);
          snprintf(linha3, sizeof(linha3), "num. pulsos:");
          snprintf(linha4, sizeof(linha4), "%d", numPulsos);
          exibirMensagem(linha1, linha2, linha3, linha4);
        }

        void exibirMensagem(const char* linha1, const char* linha2, const char* linha3, const char* linha4) {
          u8g.firstPage();
          do {
            u8g.setFont(MY_FONT);
            if (linha1 && strlen(linha1) > 0) u8g.drawStr(0, 10, linha1);
            if (linha2 && strlen(linha2) > 0) u8g.drawStr(0, 25, linha2);
            if (linha3 && strlen(linha3) > 0) u8g.drawStr(0, 40, linha3);
            if (linha4 && strlen(linha4) > 0) u8g.drawStr(0, 55, linha4);
          } while (u8g.nextPage());
        }

        void exibirMensagemSerial(const char* linha1, const char* linha2, const char* linha3, const char* linha4) {
          Serial.println(linha1);
          if (strlen(linha2) > 0) Serial.println(linha2);
          if (strlen(linha3) > 0) Serial.println(linha3);
          if (strlen(linha4) > 0) Serial.println(linha4);
        }

        // Atualiza o piscar do LED de forma não bloqueante
        void atualizarBlinkLED() {
          if (blinkActive) {
            if (millis() - lastBlinkTimeNB >= blinkIntervalNB) {
              // Alterna o estado do LED
              if (digitalRead(blinkPinNB) == HIGH) {
                digitalWrite(blinkPinNB, LOW);
              } else {
                digitalWrite(blinkPinNB, HIGH);
              }
              lastBlinkTimeNB = millis();
              blinkCountNB++;
              if (blinkCountNB >= 2 * blinkCountTarget) {
                digitalWrite(blinkPinNB, LOW);
                blinkActive = false;
              }
            }
          }
        }

        void aguardarPressionarBotao() {
          while (digitalRead(PIN_BOTAO_Y) == LOW) {
            delay(50);
          }
        }

        void calcularPeriodoEDutyCycle(unsigned long dutyCiclePositivoAcumuladoMs, 
                                        unsigned long dutyCicleNegativoAcumuladoMs,
                                        unsigned long contadorAmostrasPositivas, 
                                        unsigned long contadorAmostrasNegativas,
                                        unsigned long &T2) {
          unsigned long totalAmostras = contadorAmostrasPositivas + contadorAmostrasNegativas;
          if (totalAmostras > 0) {
            periodoLaser = (dutyCiclePositivoAcumuladoMs + dutyCicleNegativoAcumuladoMs) / totalAmostras;
          } else {
            periodoLaser = 0;
          }
          if (contadorAmostrasPositivas > 0 && contadorAmostrasNegativas > 0) {
            T2 = (dutyCiclePositivoAcumuladoMs / contadorAmostrasPositivas) +
                (dutyCicleNegativoAcumuladoMs / contadorAmostrasNegativas);
          } else {
            T2 = 0;
          }
        }

        bool verificarFrequenciaAlta(unsigned long T2) {
          if (T2 == 0) {
            exibirMensagem("Frequencia muito", "alta, diminua", "e aperte amarelo");
            aguardarPressionarBotao();
            return true;
          }
          return false;
        }

        void exibirResultadosCalibracao(unsigned long T2, int Dp, int Dm) {
          char linha1[32], linha2[32], linha3[32];
          snprintf(linha1, sizeof(linha1), "T = %lu ms", T2);
          snprintf(linha2, sizeof(linha2), "D+ = %d%%", Dp);
          snprintf(linha3, sizeof(linha2), "D- = %d%%", Dm);
          exibirMensagem(linha1, linha2, linha3);
          exibirMensagemSerial(linha1, linha2, linha3);
          delay(2000);
        }

        void setup() {
          inicializarDisplay();
          configurarPinos();
          Serial.begin(57600);
          
          determinarLuzAmbiente();
          exibirMensagem("Aperte o botao", "amarelo para", "calibrar");
          aguardarPressionarBotao();
          botaoCalibracao();
        }

        void loop() {
          atualizarContadorPulsos();
          processarCorPulsosNB();
          calibrarLaser();
          atualizarBlinkLED();  // Atualiza o piscar do LED se ativo
          
          if (digitalRead(PIN_BOTAO_Y) == HIGH) {
            botaoCalibracao();  // Permite recalibrar
          }
        }
   
      </pre>
      
      
      
      <h6>Análise do Programa</h6>
      <ol>
        <li>
          <p>Bibliotecas e Definições Iniciais:</p>
          <ul>
            <li>Usa as bibliotecas <code>Wire.h</code> (comunicação I2C) e <code>U8glib.h</code> (display OLED).</li>
            <li>Define constantes para endereço do display, fonte, tempo limite e fator de escala da luz.</li>
            <li>Define pinos para LEDs, botão e sensor de luz.</li>
          </ul>
        </li>

        <li>
          <p>Variáveis Globais:</p>
          <ul>
            <li>Armazena valor da luz ambiente, contador de pulsos, tempo do último pulso, estado do sensor, etc.</li>
            <li>Variáveis para máquina de estados, processamento não bloqueante e piscar do LED.</li>
            <li>Objeto <code>u8g</code> para o display OLED.</li>
          </ul>
        </li>

        <li>
          <p>Configuração (<code>setup()</code>):</p>
          <ul>
            <li>Inicializa display e serial.</li>
            <li>Configura pinos.</li>
            <li>Mede luz ambiente.</li>
            <li>Espera botão para calibrar.</li>
          </ul>
        </li>

        <li>
          <p>Loop Principal (<code>loop()</code>):</p>
          <ul>
            <li>Chama funções para:
              <ul>
                <li>Detectar e contar pulsos (<code>atualizarContadorPulsos()</code>).</li>
                <li>Processar pulsos (não bloqueante) (<code>processarCorPulsosNB()</code>).</li>
                <li>Executar máquina de estados da calibração (<code>calibrarLaser()</code>).</li>
                <li>Piscar LED (não bloqueante) (<code>atualizarBlinkLED()</code>).</li>
              </ul>
            </li>
            <li>Verifica botão para recalibrar.</li>
          </ul>
        </li>

        <li>
          <p>Máquina de Estados da Calibração (<code>calibrarLaser()</code>):</p>
          <ul>
            <li>Estados: <code>INICIO_CALIBRACAO</code>, <code>MEDINDO_TRANSICOES</code>, <code>CALCULANDO_RESULTADOS</code>, <code>AGUARDANDO_COR</code>.</li>
            <li><code>calibrarLaser()</code> executa a lógica do estado atual:
              <ul>
                <li><code>INICIO_CALIBRACAO</code>: Inicializa variáveis.</li>
                <li><code>MEDINDO_TRANSICOES</code>: Mede tempos do sinal do laser.</li>
                <li><code>CALCULANDO_RESULTADOS</code>: Calcula período/duty cycle (não bloqueante).</li>
                <li><code>AGUARDANDO_COR</code>: Espera por pulsos.</li>
              </ul>
            </li>
          </ul>
        </li>

        <li>
          <p>Detecção e Contagem de Pulsos (<code>atualizarContadorPulsos()</code>):</p>
          <ul>
            <li>Verifica se há pulso (abaixo do limiar).</li>
            <li>Detecção de borda.</li>
            <li>Incrementa contador e registra tempo.</li>
          </ul>
        </li>

        <li>
          <p>Processamento de Pulsos (Não Bloqueante) (<code>processarCorPulsosNB()</code>):</p>
          <ul>
            <li>Verifica tempo limite.</li>
            <li>Acende LED e exibe mensagem.</li>
            <li>Apaga LED e reseta contador após 1s (não bloqueante).</li>
          </ul>
        </li>

        <li>
          <p>Funções de Apoio:</p>
          <ul>
            <li>Funções para display, pinos, sensor, mensagens, LEDs, medir luz, calcular período, esperar botão.</li>
          </ul>
        </li>
      </ol>

      
      
<!--      <h6><a href="exemplos/exemplo3.1.39.html" target="_blank">Exemplo 3.1.39</a></h6>
      <p>
        Avalie a integral
        \[
          I= \iint_R \sqrt{x^2 + y^2} dA
        \]
        onde $R$ é a região delimitada pela curvas $x^2 +y^2=2x$,  $x^2 + y^2 = 4x$, $y=x$ e e $y=\dfrac{\sqrt{3}}{3}x$.
      </p>-->     
      
<!--       <script src="../../../../../../css_e_js/math07.js"></script> -->
      
      <!--
            
      <img src="../../../../../../figuras/linha_b.png">  
      
      
      
      <div style="width:100%;margin-left: auto;margin-right: auto;">
        <div style="display: flex; padding-bottom: 0px;">
        
          <div style="flex: 30%; padding-right: 30px">
            <a href="javascript:newWin('figuras/figCone02_a.png', 'Zoom', '1650')">
              <img src="figuras/figCone02_a.png" style="width:100%">
            </a>
            <p style="text-align: center; font-size:80%">
              <b>a)</b> Gráfico de $\displaystyle f(x,y)=\sqrt{x^2+y^2}$
            </p>
          </div>
          
          <div style="flex: 30%; padding-left: 30px;">
            <a href="javascript:newWin('figuras/figCone02_b1.png', 'Zoom', '1650')">
              <img src="figuras/figCone02_b1.png" style="width:100%">
            </a>
            <p style="text-align: center; font-size:80%">
              <b>b)</b> Interseções de planos com cone
            </p>
          </div>
          
          <div style="flex: 30%; padding-left: 30px;">
            <a href="javascript:newWin('figuras/figCone02_b2.png', 'Zoom', '1650')">
              <img src="figuras/figCone02_b2.png" style="width:100%">
            </a>
            <p style="text-align: center; font-size:80%">
              <b>c)</b> Analise do gráfico do cone $\displaystyle f(x,y)=\sqrt{x^2+y^2}$
            </p>
          </div>
          
        </div>
      </div>
      

      
      <figure style="margin-top:-30px">
        <div class = "ggbContainer"> 
          <a href="https://www.geogebra.org/material/iframe/id/dhppzd7w/width/836/height/502/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/false/rc/false/ld/false/sdz/true/ctl/false" width="836px" height="502px" style="border:0px;" width="836px" height="502px" style="border:0px;">
            Abrir com o<br>GeoGebra
          </a>
          <img src="figuras/curvasDeNivelGeo.png" width="836px" height="502px" alt="polar_coordinates" class="border" >
          <iframe src="figuras/curvasDeNivelGeo.png" allowfullscreen width="836px" height="502px" class="hiddenIframe"></iframe>
        </div>       
      </figure>
      -->
      
<!--




    <h6><a href="exemplos/exemplo1.4.23.html" target="_blank">Exemplo Q1.4.23</a></h6>
        Encontre a área do refletor parabólico cuja forma se obtém ao rotar o arco parabólico $y=x^2$, $9\leq x \leq 1$ ao redor do eixo $y$
      <p>-->
      
    <!--  
      <h6><a href="exemplos/exemplo1.4.22.html" target="_blank">Exemplo Q1.4.22</a></h6>
      
      <p>
        
      </p>    <h6><a href="exemplos/exemplo1.4.2.html" target="_blank">Exemplo Q1.4.3</a></h6>
      
      <p>
        
      </p>-->
      
     
      
<!--      <h5>Exemplo 3</h5>
      <p>
        Escreva a identidade de Parseval correspondente ao problema \ref{ex1.3.2}.\ref{ex397}
      </p>-->
<!--
      \left( \right)   \left|\, z \,\right|  
      
      \left[ \right]   \left\{ \righ\}
        
        \begin{align*}
        \end{align*}
       
      <ol>
        <li>
          
        </li>
        <li>
          
        </li>
      </ol>
        
        \[
          \begin{bmatrix}
          \end{bmatrix}
        \]
      

      <div align="center">
        <a href="javascript:newWin('figuras/fig01.png', 'Zoom', '1650')">
          <img src="figuras/fig01.png" width="400" align="center">
        </a>
          <p style="padding-left: 50px; padding-right: 50px; text-align: justify;font-size: 75%;">
            Figura 01:  Sistema massa mola.
          </p>
      </div>
      
      
      
      <div style='padding: 15px; width: 425px;float:right;'>
          <img src="figuras/Bessel32.gif" width="400" align="right">
          <p style="padding-left: 50px; padding-right: 50px; text-align: justify;font-size: 75%;">
            Figura 01:  Uma solução do problema da membrana vibrante a qual é dada em termos da funções de Bessel.
          </p>
      </div>
      
      <h5>Exemplo 03</h5>
      
      <p>
        
        <img src="figuras/linha_b.png">
      </p>
         
      <table class="tabela_de_lista2">      
      <tr>
      <td class="definicaotitulo">
        Definição de função vetorial
      </td>
      </tr>
      <tr>
      <td class="definicao">
      <p><em>
        
      </em></p>
      </td></tr>
      </table>
      
      <table class="tabela_de_lista2">      
      <tr>
      <td class="teorematitulo">
        Teorema
      </td>
      </tr>
      <tr>
      <td class="teorema">
      <p><em>
        
      </em></p>
      </td></tr>
      </table>
      
-->
      
      
      </div>
      <!-- Fim Principal   -->      
    </div>
    <!-- Fim todo   -->
  </body>
</html>
