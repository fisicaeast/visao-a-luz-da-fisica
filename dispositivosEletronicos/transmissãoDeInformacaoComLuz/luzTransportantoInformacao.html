<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
    <title>Página de Física EAST</title>
    
    <link type="text/css" rel="stylesheet" href="../../css/aulas.css" />   
    <link type="text/css" rel="stylesheet" href="css_e_js/local.css" />

    <link href='../../comunHtml/syntaxhighlighter/styles/shCore.css' rel='stylesheet' type='text/css' />
    <link href='../../comunHtml/syntaxhighlighter/styles/shThemeDefault.css' rel='stylesheet' type='text/css' />
    <script src='../../comunHtml/syntaxhighlighter/scripts/shCore.js' type='text/javascript'></script>
    <script src='./comunHtml/syntaxhighlighter/scripts/shAutoloader.js' type='text/javascript'></script>
    <script src='../../comunHtml/syntaxhighlighter/scripts/shBrushXml.js' type='text/javascript'></script>
    <script src='../../comunHtml/syntaxhighlighter/scripts/shBrushJScript.js' type='text/javascript'></script>
    <script src='../../comunHtml/syntaxhighlighter/scripts/shBrushCss.js' type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushPython.js" type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushPhp.js" type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushFortran.js" type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushCpp.js"  type='text/javascript'></script>
    <script src="../../comunHtml/syntaxhighlighter/scripts/shBrushAsm.js"  type='text/javascript'></script>
    <script type="text/javascript">
      SyntaxHighlighter.config.clipboardSwf = '../../comunHtml/syntaxhighlighter/scripts/clipboard.swf';https://tex.stackexchange.com/questions/58141/equations-inside-enumerate-aligned-on-items-number
      SyntaxHighlighter.all();
    </script>

     <script>
       window.MathJax = {
         tex: {
           tags: 'ams',
           inlineMath: [['$', '$'], ['\\(', '\\)']],
           macros: {
              bra: ["{\\left\\langle #1 \\right\\rvert}",1],
              ket: ["{\\left\\lvert #1 \\right\\rangle}",1],
              braket:["{\\left\\langle #1 \\vert #2 \\right\\rangle}",2],
              opProj:["{\\left\\lvert #1 \\right\\rangle\\left\\langle #1 \\right\\rvert}",1],
              opUni:["{\\left\\lvert #1 \\right\\rangle\\left\\langle #1 \\right\\rvert \+ \\left\\lvert #2 \\right\\rangle\\left\\langle #2 \\right\\rvert}",2],
              arcsec: "{\\operatorname{arcsec}}",
              arccot: "{\\operatorname{arccot}}",
              arccsc: "{\\operatorname{arcsc}}",
              sech: "{\\operatorname{sech}}",
              csch: "{\\operatorname{csch}}",
              argsinh: "{\\operatorname{arg sinh}}",
              argcosh: "{\\operatorname{arg cosh}}",
              argtanh: "{\\operatorname{arg tanh}}",
              argcoth: "{\\operatorname{arg coth}}",
              argsech: "{\\operatorname{arg sech}}",
              argcsch: "{\\operatorname{arg csch}}",
              dbar: "{\\mathscr'26\\mkern-12mu \\mathrm{d}}"
          }
         }
       };
     </script>    

    <script src="../../comunHtml/mathjax_new/tex-chtml.js" id="MathJax-script" async></script>
    
    <script type="text/javascript">
      function newWin(url, name, width) { 
      window.open(url,name,'scrollbars=yes,resizable=yes, width=' + width);}
    </script>
    
    <script src="../../comunHtml/jquery/dist/jquery.min.js"></script>
    <script>
    $(document).ready(function(){
      $(".expand").click(function(){
        target_num = $(this).attr("id").split("-")[1];
        content_id = "#expandable-".concat(target_num);
        $(content_id).slideToggle('fast');
      });
    });
    </script>

    <style>
      .expand {
        font-style: italic;
        font-size: 12px;
        cursor: pointer;
        color: blue;
      }
        .expandable {
        display:none;
        margin-left: 3%;
        margin-right: 3%;
        color: #3e3e3e;
/*         text-align: justify; */
      }
    </style>
    
    <style>
      ol.alpha_list {
        counter-reset: item;
        list-style: none;
      }
      ol.alpha_list li:before {
        content: counter(item,  lower-latin) ")  ";
        counter-increment: item;
        margin-left: -30px;
      }
    </style>

</head>

  <body>
    <div id="todo">

      <div id="titulo">      
        <div id="cabezado">
          <h1>Visão à luz da Física</h1>
        </div>

        <div >
          <img src="../../figuras/divisorHorizontal.png" alt="só um divisor"></img>
        </div>


      <!-- Inicio Principal   -->
      <div id="principal">
      
      <h2>Transmissão de informação utilizando luz</h2>
      
      <p>
        Com o auxílio do dispositivo que descreveremos a seguir, será possível discutir com os alunos como a informação pode ser transmitida utilizando luz. Para isso, será proposta uma forma simples de codificação da informação, que permitirá apresentar as ideias básicas relacionadas aos protocolos de comunicação.
      </p>
      
      <p>
        O dispositivo experimental utilizado foi constituído por duas partes: um emissor de luz laser pulsada, onde se codifica e transmite a informação, e um receptor de luz, que decodifica a informação e executa uma ação. No caso do receptor forma utilizado duas versões, uma com o sensor LDR e outra com o sensor BPW34
      </p>
        
      <div  align="center">
        <a href="javascript:newWin('figuras/fig01.png', 'Zoom', '1650')">
          <img src="figuras/fig01.png" style="width:80%">
        </a>
        <p style="text-align: center; font-size:70%">
          Figura 01: À esquerda emissão de pulsos laser, à direita o receptor.
        </p>
      </div>
      
      <h3>Aplicação</h3>
      
      <p>
        Para utilizar o dispositivo, siga os seguintes passos:
        <ol>
          <li>
            Ligar o Receptor
            <ol>
              <li>
                Conecte o Receptor à fonte de alimentação. Se o Arduino já estiver energizado, isso equivale a apertar o botão de reset.
              </li>
              <li>
                O Receptor realizará leituras do sensor da luz do ambiente durante 10 segundos para calcular um valor médio de referência que será usado para distinguir o feixe do laser da luz do ambiente.
              </li>
            </ol>
          </li>
          <li>
            Calibração Inicial do Receptor
            <ol>
              <li>
                Após a medição da luz ambiente, o display do Receptor exibirá a mensagem "Aperte o botão amarelo para calibrar".
              </li>
              <li>
                Quando o laser estiver pronto para emitir, aperte o botão amarelo no Receptor para que ele entre em modo de calibração, onde:
                <ol>
                  <li>O Receptor monitora as transições do sinal do laser.</li>
                  <li>
                    As medidas são realizadas até que o sensor não registre variações por mais de 500 ms.
                  </li>
                  <li>
                    Após esse período de inatividade, o Receptor calcula a frequência e o duty cycle (D+ e D-) do sinal (tempo que fica ligado e tempo que fica desligado) e exibe os resultados no display e no Serial; por fim, pisca o LED branco cálido imitando a frequência medida.
                  </li>
                  <li>
                    Se a frequência medida for muito alta (por exemplo, T = 0), o receptor imprimirá no OLED que a frequência deve ser reajustada para um valor menor e que o botão amarelo seja pressionado novamente.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            Ligar o Emissor
            <ol>
              <li>
                Conecte o Emissor à fonte de alimentação.
              </li>
              <li>
                Logo após ligar, o Emissor entra no estado de ajuste de período, para isso deve seguir-se os seguintes passos:
                <ol>
                  <li>
                    Gire o potenciômetro para alterar o período do laser, sendo possível obter pulsos com &Delta;T de 1 a 132 ms.
                  </li>
                  <li>
                    O display mostra o período de oscilação (o dobro do tempo de cada pulso do laser).
                  </li>
                  <li>
                    Concluído o ajuste, aperte o botão amarelo no Emissor para confirmar o período. Em seguida, o Emissor exibirá "Ligue o receptor" e aguardará 5 segundos antes de ligar o laser.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            Calibração do Emissor
            <ol>
              <li>
                Após a pausa de 5 segundos, o Emissor emitirá os pulsos do laser, piscando o LED branco quente em sincronia com o laser por 20 segundos.
              </li>
              <li>
                Se necessário, repita a calibração pressionando novamente o botão amarelo para acessar a função de calibração.
              </li>
            </ol>
          </li>
          <li>
            Sincronização da Calibração no Receptor
            <ol>
              <li>
                Caso o Receptor ainda não tenha lido a frequência ou se você desejar recalibrá-lo, aperte o botão amarelo no Receptor enquanto o Emissor estiver emitindo seus pulsos de calibração.
              </li>
              <li>
                O Receptor monitorará as transições do laser até detectar 500 ms sem variações. Seguidamente, serão realizados os cálculos e exibidos os resultados (período T, duty cycle D+ e D-) no display.
              </li>
            </ol>
          </li>
          <li>
            Emissão de Pulsos Coloridos
            <ol>
              <li>
                Após as calibrações, o Emissor passa para o estado de espera, imprimindo no display a mensagem "Calibração concluída. Aperte algum botão".
              </li>
              <li>
                O usuário pode voltar ao estado de ajuste da frequência do laser ou escolher apertar algum dos botões coloridos, cada botão desses emitirá uma quantidade específica de pulsos:
                <ol>
                  <li>Vermelho: emite T1 pulsos.</li>
                  <li>Verde: emite T2 pulsos.</li>
                  <li>Azul: emite T3 pulsos.</li>
                </ol>
              </li>
              <li>
                Cálculo dos Pulsos: O número desses pulsos é calculado conforme:
                <ol>
                  <li>\( T0 = \dfrac{2000}{\Delta T} \)</li>
                  <li>\( T1 = 0,95 \times T0 \)</li>
                  <li>\( T2 = 0,95 \times \left(2 \times T0\right) \)</li>
                  <li>\( T3 = 0,95 \times \left(3 \times T0\right) \)</li>
                </ol>
                sendo &Delta;T a metade do período do laser. O fator de 0,95 leva em consideração o fato de que o &Delta;T calculado no emissor não é exatamente igual ao &Delta;T detectado no receptor, existindo ligeiras divergências de 1 a 2 ms, se o sensor LDR for utilizado.
              </li>
            </ol>
          </li>
          <li>
            Detecção e Classificação no Receptor.
            <ol>
              <li>
                O Receptor conta o número de pulsos recebidos até que haja um período de inatividade. Dependendo do número desses pulsos, um LED vermelho, verde ou azul será ligado por 1 s.
              </li>
              <li>
                Internamente o receptor determina o valor de \( T0 \) usando a mesma equação anterior
                \[
                  T0 = \dfrac{2000}{\Delta T}
                \]
                e, a partir desse valor, estabelece os limites de intervalo de pulsos que correspondem a cada cor, conforme:
                <ul>
                  <li>Vermelho: entre 0 e T1 pulsos;</li>
                  <li>Verde: entre T1 e 2 T1 pulsos;</li>
                  <li>Azul: entre 2 T1 e 3 T1 pulsos.</li>
                </ul>
                Ao final, uma mensagem no display informará a cor detectada e a quantidade de pulsos.
              </li>
              <li>
                Se o número de pulsos for maior do que 3 T1 pulsos, o Receptor exibirá uma mensagem de "pulsos inválidos".
              </li>
            </ol>
          </li>
        </ol>
      </p>
      
      <h3>Materiais</h3>

      <p>
        Para o emissor:
        <ul>
          <li>1 Arduino Nano</li>
          <li>1 Fonte ajustável para protoboard</li>
          <li>1 matriz de contato ou protoboard MB102</li>
          <li>4 resistores de 10 k&Omega; e 1 resistor de 330 &Omega;</li>
          <li>1 Potenciômetro, $P_1 = 10 k&Omega;</li>
          <li>4 botões (push button), com capas nas cores vermelho, verde, azul e amarelo</li>
          <li>1 telinha OLED de 0,96 polegadas</li>
          <li>Cabos de conexão, 23 - 24 AWG (diâmetro entre 0,574 e 0,511 mm)</li>
          <li>1 LED branco quente</li>
        </ul>
      </p>

      <p>
        Para o receptor utilizamos os itens comuns:
        <ul>
          <li>1 Arduino Nano</li>
          <li>1 Fonte ajustável para protoboard</li>
          <li>1 matriz de contato ou protoboard MB102</li>
          <li>4 resistores de 330 &Omega;, e 1 resistor de 10 k&Omega;</li>
          <li>1 botão (push button), com capa na cor amarela</li>
          <li>1 telinha OLED de 0,96 polegadas</li>
          <li>Cabos de conexão, 23 - 24 AWG (diâmetro entre 0,574 e 0,511 mm)</li>
          <li>4 LEDs nas cores vermelho, verde, azul e branco quente</li>
        </ul>
      </p>

      <p>
        Itens adicionais (dependendo do sensor utilizado):
        <ul>
          <li>No caso do LDR, é utilizado 1 resistor de 1 k&Omega;</li>
          <li>Se é o BPW34, é utilizado um resistor de 410 &Omega;</li>
        </ul>
      </p>
      
      <h3>Montagem</h3>
      
      <h4>Emissor</h4>
      
      <div style="flex: 30%; padding-right: 30px">
        <a href="javascript:newWin('figuras/fig02.png', 'Zoom', '1650')">
          <img src="figuras/fig02.png" style="width:100%">
        </a>
        <p style="text-align: center; font-size:80%">
          Figura 02: Emissor, à direita a foto real, à esquerda esquema do feito com fritzing, embaixo o esquema de ligação
        </p>
      </div>

      <p>
        <ul>
          <li>
            Coloque o Arduino NANO no centro, próximo a um dos extremos da protoboard MB102.
          </li>
          <li>
            No outro extremo do MB102 coloque a fonte de energia respeitando a polaridade: positivo no trilho vermelho e negativo na trilha azul.
          </li>
          <li>
            Conecte o terminal central do potenciômetro de 10 k&Omega; ao pino A0 do Arduino. Os outros terminais devem ser ligados aos trilhos azul e vermelho para fornecer energia.
          </li>
          <li>
            Ligue o terminal negativo do laser ao trilho azul do protoboard e o pino S do laser ao pino D7 do Arduino.
          </li>
          <li>
            Ligue o ânodo (terminal mais comprido) do LED branco quente ao pino 6 do Arduino, através de um resistor de 330 &Omega;. O cátodo desse LED deve ser ligado ao trilho preto do protoboard.
          </li>
          <li>
            O terminal GND da telinha OLED deve ser ligado à trilha vermelha do protoboard e o terminal VCC à trilha azul. Os terminais SDA e SCL devem ser ligados aos pinos A4 e A5 do Arduino, respectivamente.
          </li>
          <li>
            Os quatro botões devem ser distribuídos no espaço disponível entre o display OLED e a fonte de tensão do protoboard. A configuração adotada para a ligação com o Arduino é a chamada "Pull-down": Um dos lados do botão é conectado à fonte de energia (trilho vermelho), e o outro terminal é conectado ao trilho azul através de um resistor de R = 10 k&Omega;. Um dos outros dois terminais (aquele oposto ao terminal em série com a resistência) é ligado diretamente aos pinos D5, D4, D3, D2; relativos aos botões que estão próximos ao OLED, em direção à fonte de tensão do protoboard.
          </li>
        </ul>
      </p>
      
      <div style="flex: 30%; padding-right: 30px">
        <a href="javascript:newWin('figuras/fig03.png', 'Zoom', '1650')">
          <img src="figuras/fig03.png" style="width:100%">
        </a>
        <p style="text-align: center; font-size:80%">
          Figura 03: Esquema de ligação do emissor
        </p>
      </div>
      
      <h5>Programação</h5>
      
      <p>
        Este programa é uma versão melhorada do utilizado originalmente. A essência do programa original não foi modificada somante alterando a organização e estruturação do mesmo, alterando o nome das variáveis a fim de tornar elas mais em acordo com seu uso dentro do programa
      </p>
      
      <pre class="brush: cpp;">
        #include &lt;Wire.h&gt;
        #include &lt;U8g2lib.h&gt;

        // ================== DEFINIÇÕES E VARIÁVEIS GLOBAIS ==================

        // Display
        #define MY_FONT u8g2_font_9x18_tr
        U8G2_SSD1306_128X64_NONAME_1_HW_I2C display(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); // Voltamos ao construtor C++

        // Pinos
        int pinBotaoR = 2;
        int pinBotaoG = 3;
        int pinBotaoB = 4;
        int pinBotaoY = 5;
        int pinLed    = 6;
        int pinLaser  = 7;

        // Leitura do potenciômetro
        int valor_pot;
        int tempoDelay = 10;

        // Quantidade de pulsos (float)
        float T1, T2, T3;

        // Porcentagem de pulsos
        #define PORC_PULSOS 0.95f

        // Estados dos botões (voltamos a usar bool)
        bool sitBotaoR = false; // false = LOW = não pressionado
        bool sitBotaoG = false;
        bool sitBotaoB = false;
        bool sitBotaoY = false;

        // Variáveis de calibração
        unsigned long t1 = 0, t2 = 0, t1Local;
        bool estado = false;

        // Cor selecionada (1=R, 2=G, 3=B)
        int corSelecionada = 0;

        // ================== MÁQUINA DE ESTADOS ==================

        enum EstadoEmissor {
          EST_INICIAL,
          EST_AJUSTA_PERIODO,
          EST_CALIBRA_LASER,
          EST_AGUARDA_ACAO,
          EST_EMITE_PULSO
        };

        EstadoEmissor estadoAtual = EST_INICIAL;

        // ================== PROTÓTIPOS DE FUNÇÕES ==================

        void maquinaDeEstadosEmissor();
        void estadoAjustaPeriodo();
        void estadoCalibraLaser();
        void estadoAguardaAcao();
        void estadoEmitePulso();
        void blink(int n);
        void calibra();
        void mudaFrequencia();
        void mensagem(int cor);
        void logMensagem(const String& linha1, const String& linha2 = "", const String& linha3 = "", const String& linha4 = ""); // Usando String


        // ================== SETUP ==================

        void setup() {
            Serial.begin(57600);

            pinMode(pinLed, OUTPUT);
            pinMode(pinLaser, OUTPUT);
            pinMode(pinBotaoR, INPUT); // Pull-down externo, então INPUT
            pinMode(pinBotaoG, INPUT);
            pinMode(pinBotaoB, INPUT);
            pinMode(pinBotaoY, INPUT);

            // Inicializa display (C++)
            Wire.begin();
            display.begin();        // Muito mais simples!
            display.setPowerSave(0); // Desliga power save

            estadoAtual = EST_AJUSTA_PERIODO;
            logMensagem("Emissor Iniciado");
        }

        // ================== LOOP PRINCIPAL ==================

        void loop() {
            // Leitura dos botões (HIGH = pressionado, LOW = não pressionado)
            sitBotaoR = digitalRead(pinBotaoR);
            sitBotaoG = digitalRead(pinBotaoG);
            sitBotaoB = digitalRead(pinBotaoB);
            sitBotaoY = digitalRead(pinBotaoY);

            // Executa a máquina de estados
            maquinaDeEstadosEmissor();
        }

        // ------------------ MÁQUINA DE ESTADOS ------------------
        void maquinaDeEstadosEmissor() {
          switch (estadoAtual) {
            case EST_INICIAL:
              break;

            case EST_AJUSTA_PERIODO:
              estadoAjustaPeriodo();
              break;

            case EST_CALIBRA_LASER:
              estadoCalibraLaser();
              break;

            case EST_AGUARDA_ACAO:
              estadoAguardaAcao();
              break;

            case EST_EMITE_PULSO:
              estadoEmitePulso();
              break;
          }
        }

        // ------------------ ESTADO: AJUSTA PERIODO ------------------
        void estadoAjustaPeriodo() {
          mudaFrequencia();
          estadoAtual = EST_CALIBRA_LASER;
        }

        // ------------------ ESTADO: CALIBRA LASER ------------------
        void estadoCalibraLaser() {
          calibra();
          estadoAtual = EST_AGUARDA_ACAO;
        }

        // ------------------ ESTADO: AGUARDA AÇÃO (BOTÕES) ------------------
        void estadoAguardaAcao() {
            // Se o botão Y for pressionado, voltamos para ajustar período.
          if (sitBotaoY == HIGH) { // Agora HIGH significa pressionado.
            estadoAtual = EST_AJUSTA_PERIODO;
            logMensagem("Botao amarelo", "Voltando Ajuste");
            return;
          }
          // Se algum dos botões R, G ou B for pressionado, vamos emitir pulso.
          if (sitBotaoR == HIGH) { // Agora HIGH significa pressionado.
            corSelecionada = 1; // Vermelho
            estadoAtual = EST_EMITE_PULSO;
            logMensagem("Botao vermelho");
          }
          else if (sitBotaoG == HIGH) { // Agora HIGH significa pressionado.
            corSelecionada = 2; // Verde
            estadoAtual = EST_EMITE_PULSO;
            logMensagem("Botao verde");
          }
          else if (sitBotaoB == HIGH) { // Agora HIGH significa pressionado.
            corSelecionada = 3; // Azul
            estadoAtual = EST_EMITE_PULSO;
            logMensagem("Botao azul");
          }
        }

        // ------------------ ESTADO: EMITE PULSO ------------------
        void estadoEmitePulso() {
          // Emite a quantidade de pulsos *ajustada* conforme a cor.
          if (corSelecionada == 1) {
            blink(static_cast&lt;int&gt;(T1)); // Converte float para int
            mensagem(1);
          } else if (corSelecionada == 2) {
            blink(static_cast&lt;int&gt;(T2)); // Cast para int
            mensagem(2);
          } else if (corSelecionada == 3) {
            blink(static_cast&lt;int&gt;(T3)); // Cast para int
            mensagem(3);
          }
          estadoAtual = EST_AGUARDA_ACAO;
        }

        // ================== FUNÇÕES DE APOIO ==================

        void blink(int n){
          for (int i=0; i < n; i++){
            digitalWrite(pinLed,   HIGH);
            digitalWrite(pinLaser, HIGH);
            delay(tempoDelay);
            digitalWrite(pinLaser, LOW);
            digitalWrite(pinLed,   LOW);
            delay(tempoDelay);
          }
        }

        void calibra(){
          t1Local = millis();
          do {
            t2 = millis();
            if (t2 - t1 >= tempoDelay){
              t1 = t2;
              digitalWrite(pinLaser, estado);
              digitalWrite(pinLed,   estado);
              estado   = !estado;
            }
          } while (millis() - t1Local < 20000);

          digitalWrite(pinLaser, LOW);
          digitalWrite(pinLed,   LOW);
          logMensagem("Calibracao", "concluida ...", "Aperte algum", "botao");
        }

        // Funções com Modificações (mudaFrequencia, mensagem, logMensagem):

        void mudaFrequencia() {
            logMensagem("Aj. o Periodo", "Amarelo para sair");

            do {
                valor_pot = analogRead(A0);
                tempoDelay = map(valor_pot, 0, 1023, 1, 132); // Simplificado com map() do Arduino

                logMensagem("Aj. o periodo", "Periodo: " + String(2 * tempoDelay) + " ms", "Amarelo para", "sair"); // Usando String

                sitBotaoY = digitalRead(pinBotaoY);
            } while (sitBotaoY == LOW);

            logMensagem("Ligue", "o receptor");
            delay(5000);

            // Calcula T1, T2 e T3 (sem porcentagem primeiro)
            float T1_original = (2000.0f / tempoDelay);
            float T2_original = 2.0f * T1_original;
            float T3_original = 3.0f * T1_original;

            // Aplica a porcentagem
            T1 = T1_original * PORC_PULSOS;
            T2 = T2_original * PORC_PULSOS;
            T3 = T3_original * PORC_PULSOS;

            logMensagem("Periodo Ajustado",
                        "T1: " + String(int(T1)),  // Conversão implícita e explícita para int
                        "T2: " + String(int(T2)),
                        "T3: " + String(int(T3)));

            t1 = millis(); // Para a calibração.
        }

        void mensagem(int cor) {
            String linha1;
            String linha2;

            if (cor == 1) {
                linha1 = "Vermelho:";
                linha2 = String(int(T1)) + " pulsos"; // String + int
            } else if (cor == 2) {
                linha1 = "Verde:";
                linha2 = String(int(T2)) + " pulsos";
            } else if (cor == 3) {
                linha1 = "Azul:";
                linha2 = String(int(T3)) + " pulsos";
            }

            logMensagem(linha1, linha2);
        }

        void logMensagem(const String& linha1, const String& linha2, const String& linha3, const String& linha4) {
            display.firstPage();
            do {
                display.setFont(MY_FONT);
                display.drawStr(0, 15, linha1.c_str());  // Correção aqui: drawStr, e .c_str()
                if (linha2.length() > 0) display.drawStr(0, 30, linha2.c_str()); // Correção aqui
                if (linha3.length() > 0) display.drawStr(0, 45, linha3.c_str()); // Correção aqui
                if (linha4.length() > 0) display.drawStr(0, 60, linha4.c_str()); // Correção aqui
            } while (display.nextPage());

            // Saída para o Serial Monitor (agora usando print/println)
            Serial.println(linha1);
            if (linha2.length() > 0) Serial.println(linha2);
            if (linha3.length() > 0) Serial.println(linha3);
            if (linha4.length() > 0) Serial.println(linha4);
        }
      </pre>


      
      
<!--      <h6><a href="exemplos/exemplo3.1.39.html" target="_blank">Exemplo 3.1.39</a></h6>
      <p>
        Avalie a integral
        \[
          I= \iint_R \sqrt{x^2 + y^2} dA
        \]
        onde $R$ é a região delimitada pela curvas $x^2 +y^2=2x$,  $x^2 + y^2 = 4x$, $y=x$ e e $y=\dfrac{\sqrt{3}}{3}x$.
      </p>-->     
      
<!--       <script src="../../../../../../css_e_js/math07.js"></script> -->
      
      <!--
            
      <img src="../../../../../../figuras/linha_b.png">  
      
      
      
      <div style="width:100%;margin-left: auto;margin-right: auto;">
        <div style="display: flex; padding-bottom: 0px;">
        
          <div style="flex: 30%; padding-right: 30px">
            <a href="javascript:newWin('figuras/figCone02_a.png', 'Zoom', '1650')">
              <img src="figuras/figCone02_a.png" style="width:100%">
            </a>
            <p style="text-align: center; font-size:80%">
              <b>a)</b> Gráfico de $\displaystyle f(x,y)=\sqrt{x^2+y^2}$
            </p>
          </div>
          
          <div style="flex: 30%; padding-left: 30px;">
            <a href="javascript:newWin('figuras/figCone02_b1.png', 'Zoom', '1650')">
              <img src="figuras/figCone02_b1.png" style="width:100%">
            </a>
            <p style="text-align: center; font-size:80%">
              <b>b)</b> Interseções de planos com cone
            </p>
          </div>
          
          <div style="flex: 30%; padding-left: 30px;">
            <a href="javascript:newWin('figuras/figCone02_b2.png', 'Zoom', '1650')">
              <img src="figuras/figCone02_b2.png" style="width:100%">
            </a>
            <p style="text-align: center; font-size:80%">
              <b>c)</b> Analise do gráfico do cone $\displaystyle f(x,y)=\sqrt{x^2+y^2}$
            </p>
          </div>
          
        </div>
      </div>
      

      
      <figure style="margin-top:-30px">
        <div class = "ggbContainer"> 
          <a href="https://www.geogebra.org/material/iframe/id/dhppzd7w/width/836/height/502/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/false/rc/false/ld/false/sdz/true/ctl/false" width="836px" height="502px" style="border:0px;" width="836px" height="502px" style="border:0px;">
            Abrir com o<br>GeoGebra
          </a>
          <img src="figuras/curvasDeNivelGeo.png" width="836px" height="502px" alt="polar_coordinates" class="border" >
          <iframe src="figuras/curvasDeNivelGeo.png" allowfullscreen width="836px" height="502px" class="hiddenIframe"></iframe>
        </div>       
      </figure>
      -->
      
<!--




    <h6><a href="exemplos/exemplo1.4.23.html" target="_blank">Exemplo Q1.4.23</a></h6>
        Encontre a área do refletor parabólico cuja forma se obtém ao rotar o arco parabólico $y=x^2$, $9\leq x \leq 1$ ao redor do eixo $y$
      <p>-->
      
    <!--  
      <h6><a href="exemplos/exemplo1.4.22.html" target="_blank">Exemplo Q1.4.22</a></h6>
      
      <p>
        
      </p>    <h6><a href="exemplos/exemplo1.4.2.html" target="_blank">Exemplo Q1.4.3</a></h6>
      
      <p>
        
      </p>-->
      
     
      
<!--      <h5>Exemplo 3</h5>
      <p>
        Escreva a identidade de Parseval correspondente ao problema \ref{ex1.3.2}.\ref{ex397}
      </p>-->
<!--
      \left( \right)   \left|\, z \,\right|  
      
      \left[ \right]   \left\{ \righ\}
        
        \begin{align*}
        \end{align*}
       
      <ol>
        <li>
          
        </li>
        <li>
          
        </li>
      </ol>
        
        \[
          \begin{bmatrix}
          \end{bmatrix}
        \]
      

      <div align="center">
        <a href="javascript:newWin('figuras/fig01.png', 'Zoom', '1650')">
          <img src="figuras/fig01.png" width="400" align="center">
        </a>
          <p style="padding-left: 50px; padding-right: 50px; text-align: justify;font-size: 75%;">
            Figura 01:  Sistema massa mola.
          </p>
      </div>
      
      
      
      <div style='padding: 15px; width: 425px;float:right;'>
          <img src="figuras/Bessel32.gif" width="400" align="right">
          <p style="padding-left: 50px; padding-right: 50px; text-align: justify;font-size: 75%;">
            Figura 01:  Uma solução do problema da membrana vibrante a qual é dada em termos da funções de Bessel.
          </p>
      </div>
      
      <h5>Exemplo 03</h5>
      
      <p>
        
        <img src="figuras/linha_b.png">
      </p>
         
      <table class="tabela_de_lista2">      
      <tr>
      <td class="definicaotitulo">
        Definição de função vetorial
      </td>
      </tr>
      <tr>
      <td class="definicao">
      <p><em>
        
      </em></p>
      </td></tr>
      </table>
      
      <table class="tabela_de_lista2">      
      <tr>
      <td class="teorematitulo">
        Teorema
      </td>
      </tr>
      <tr>
      <td class="teorema">
      <p><em>
        
      </em></p>
      </td></tr>
      </table>
      
-->
      
      
      </div>
      <!-- Fim Principal   -->      
    </div>
    <!-- Fim todo   -->
  </body>
</html>
